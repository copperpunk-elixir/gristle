# 6. SimPATHy

For someone who keeps using the word "autopilot", I sure have avoided the "autonomous" part of the project for a long time. Well, the time has finally come to describe how the vehicle actually pilots itself. And the good news is, the explanation is quite simple:<p align="center"><img src="images/web/aliens.jpg">[1](https://i.kym-cdn.com/photos/images/original/000/183/103/alens.jpg)</p>
But how did the alies do it? One theory is that they used [Dubins paths](https://en.wikipedia.org/wiki/Dubins_path). If you've never heard of a Dubins path, that's probably because you spent your college years with friends. Big mistake. In case you don't feel like clicking on that nicely added link, a Dubins path is essentially the shortest path between two points given a constraint on the curvature (turning radius) of the path. To create a Dubins path you just need to specify two or more waypoints, each of which includes the following information:
* 3D location (latitude, longitude, altitude)
* Heading (direction the vehicle should be headed upon reaching the waypoint)
* Speed
* Vehicle turning radius (or rate of turn)

Each segment will include a constant-radius turn, a straight line, and another constant-radius turn, as seen in this example:<p align="center"><img src="images/web/dubins_example.png" width="30%">[2](https://commons.wikimedia.org/w/index.php?curid=46816719)</p>
Pretty much everything I know about Dubins paths I learned from Randal Beard's book *Small Unmanned Aircraft: Theory and Practice*. What's awesome, is that you can view the contents of the book for free on his website: https://uavbook.byu.edu/doku.php. This material covers much more than just Dubins paths, and is a great resource if you are interested in vehicle autonomy.<br>
The unfortunate part about Dubins paths is that they involve a LOT of calculations. They aren't difficult, but there are plenty of opportunities for human error to creep in. I have rewritten these equations in 4 different languages, and every time I made several mistakes. So if you're going to take a shot at path planning with Dubins, be sure you have a way to quickly create and test paths. The nice thing is that Dubins paths are pretty straight forward to display visually, as they do not involve any complex curves. If you have a graphical interface that can handle straight lines and circles, then you can display Dubins paths. And if you can display them, you can find out rather quickly when you have problems.
## The Scenic View
One of the most popular libraries for creating user interfaces in Elixir is called [Scenic](https://github.com/boydm/scenic). If you don't like words without moving pictures, checkout the ElixirConf 2018 introduction to Scenic: https://youtu.be/1QNxLNMq3Uw. There's no doubt that Scenic is far more powerful than what I have used it for, but at the very least it's great for create simple shapes and text and updating them on demand. And since my ground control station (GCS) pretty much only uses rectangles, circles, lines, and text boxes, it was a great fit. The first thing I created was a display to include the current vehicle information, as well as the corresponding autopilot commands.<p align="center"><img src="images/Sim/gcs.png"></p>
The values in the column along the left are all the estimated values coming from the vehicle. The commands are contained in the several rows on the right. This gives you a good idea of the controller pipeline: `speed`/`course`/`altitude` commands are converted to `thrust`/`roll`/`pitch`/`yaw` commands, which are converted to `rollrate`/`pitchrate`/`yawrate` commands (thrust carries over directly). This interface was useful to tune the PID controllers in the simulator, as I could quickly compare commanded and actual values. Once vehicle flew well under manual control (and I had a decent handle on how to use Scenic), I could get to those Dubins paths everyone's been talking about.<p align="center"><img src="images/Sim/nobody_cares.jpg"></p>
The first step was try a simple, repeatable path to display correctly. I used a racetrack with all left-hand turns. In case you didn't look at any of the required reading, there are four possible Dubins segments, in regards to the turn direction for the starting and ending turns: *left-left*, *left-right*, *right-left*, and *right-right*. So a left-handed racetrack essentially only tests one of the cases: *left-left*. This is approximately not 100% of the cases. But it's a start.<p align="center"><img src="images/Sim/dubins_racetrack.png" width="30%"></p>
You'll notice the radii are either green or red, and there's some small circles at the center of said radii. But this example is terrible for explaining what those are, so let's go to the next path I tried, which was an hourglass. The waypoint locations and headings are identical to the racetrack, but the order is different, which results in all of the four Dubins segments being present. <p align="center"><img src="images/Sim/dubins_hourglass.png" width="30%"></p>
Now for red/green business (if you've never seen [The Red Green Show](https://www.youtube.com/user/RedGreenTV), you need to get your life together). As you recall from roughly two minutes ago, a Dubins segment is described as a turn-straight-turn. In color form, I have displayed this as green-white-red. The center of each turn arc is represented by a similarly-colored circle. If the two consecutive segments share a turn direction, e.g., a *right-left* followed by a *left-left* share a left turn, their arc centers are identical.<br><br>

I wish I had taken screenshots of all the messed up paths I was creating until I fixed the bugs in my code. I assure you it took a while. Once of the biggest ways I kept screwing up was related to my decision to keep all waypoint in geographic coordinates (latitude/longitude) as opposed to converting them to Cartesian coordinates (X/Y). This was contrary to how I had done things in the past, so I'm sure the newness contributed to some of the errors. But I think the biggest issue was converting latitude/longitude to displacements in terms of pixels, as was necessary in order to plot the coordinates in Scenic. This is because one degree of latitude is not the same distance as one degree of longitude. Throw in the desire to create a constant margin surrounding the waypoints, and I managed to run in circles for a couple of days trying to put that darn &#8730;2 in the right spot.<br>
Another added bit of difficult was that all the Dubins paths algorithms I have seen assume a constant turn radius for all waypoints. This seemed like an unnecessary restraint to me, so I reworked the equations to include the starting and ending turn radii as separate variables. After several days of crying, I understood why people just pick a single radius and stick with. Nevertheless, it's possible, and here is the path to prove it: <p align="center"><img src="images/Sim/dubins_hourglass_variable.png" width="30%">
